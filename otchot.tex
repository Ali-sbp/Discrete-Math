\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}
\usepackage{setspace}

\geometry{margin=2.5cm}
\onehalfspacing

\lstset{
    language=C++,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

%\title{\textbf{Лабораторная работа № 1}\\
%\large{Генерация бинарного кода Грея и операции над мультимножествами}}
%\author Студент: Aнари. М.А\\
%Группа: 5130201/40001\\
%Преподаватель: Востров А. В.}
%\date{\today}

\begin{document}
\begin{center}
		\hfill \break
		\hfill \break
		\normalsize{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ\\
			федеральное государственное автономное образовательное учреждение высшего образования «Санкт-Петербургский политехнический университет Петра Великого»\\[10pt]}
		\normalsize{Институт компьютерных наук и кибербезопасности}\\[10pt] 
		\normalsize{Высшая школа технологий и искусственного интеллекта}\\[10pt] 
		\normalsize{Направление: 02.03.01 Математика и компьютерные науки}\\
		\vspace{75pt}
		
		\vspace{2pt}
		{\large Лабораторная работа № 1 по дисциплине\\ Дискретная Математика }\\
		\large{«Генерация бинарного кода Грея и операции над мультимножествами»}\\
		\hfill \break
		
		\hfill \break
		\hfill \break
	\end{center}
	
	\small{ 
		\begin{tabular}{lrrl}
			\!\!\!Студент, & \hspace{0cm} & & \\
			\!\!\!группа 5130201/40001 & \hspace{1.5cm} & \underline{\hspace{3cm}} & \hspace{-0.3cm}Анари М.  \\\\
			\!\!\!Преподаватель, & \hspace{1cm} & \\
			\!\!\! & \hspace{1cm} & \underline{\hspace{3cm}} &  Востров А. В. \\\\
			&&\hspace{5cm}
		\end{tabular}
		\begin{flushright}
			<<\underline{\hspace{1cm}}>>\underline{\hspace{2.5cm}} 2025 г.
		\end{flushright}
	}
	
	\hfill \break
	\hfill \break
	\begin{center} \small{Санкт-Петербург, 2025} \end{center}
	\thispagestyle{empty} % выключаем отображение номера для этой страницы
	% КОНЕЦ ТИТУЛЬНОГО ЛИСТА
%\maketitle
%\newpage

\tableofcontents
\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}

В данной лабораторной работе реализована программа для генерации бинарного кода Грея заданной разрядности и выполнения операций над мультимножествами. Программа позволяет пользователю выбрать способ заполнения мультимножеств (вручную или автоматически), задать их мощности и выполнить различные операции: объединение, пересечение, разность, симметрическую разность, дополнение, а также арифметические операции.

Бинарный код Грея представляет собой систему счисления, в которой два соседних значения отличаются только в одном бите. Это свойство делает код Грея особенно полезным в цифровой электронике, коммуникациях и алгоритмах, где важно минимизировать количество изменений при переходе между состояниями. В контексте данной работы код Грея используется для генерации универсума мультимножеств, обеспечивая систематический и эффективный способ перечисления всех возможных элементов.

Мультимножества являются важным обобщением понятия множества в дискретной математике, позволяя элементам иметь кратность больше единицы. Это делает их особенно полезными для моделирования реальных ситуаций, где элементы могут повторяться с различной частотой. В программе реализованы как теоретико-множественные операции (объединение, пересечение, разность), так и арифметические операции, что позволяет проводить комплексный анализ данных, представленных в виде мультимножеств.

Программа также включает систему валидации входных данных, обеспечивающую корректность работы с мультимножествами и предотвращающую ошибки при выполнении операций. Пользовательский интерфейс спроектирован таким образом, чтобы сделать работу с программой интуитивно понятной как для начинающих, так и для опытных пользователей.

Основные задачи работы:
\begin{itemize}
    \item Реализация алгоритма генерации бинарного кода Грея
    \item Создание универсума мультимножеств на основе сгенерированного кода
    \item Реализация операций над мультимножествами
    \item Обеспечение защиты от некорректного пользовательского ввода
    \item Создание удобного пользовательского интерфейса
\end{itemize}

\newpage

\section{Математическое описание}

\subsection{Множества и мультимножества}

\textbf{Множество} — это совокупность различных элементов, где каждый элемент может принадлежать множеству только один раз.

\textbf{Мультимножество} — это обобщение понятия множества, где элементы могут повторяться. Формально мультимножество $M$ над универсумом $U$ можно определить как функцию $M: U \rightarrow \mathbb{N}_0$, где $M(x)$ — кратность элемента $x$ в мультимножестве.

\subsection{Операции над мультимножествами}

Для мультимножеств $A$ и $B$ над универсумом $U$ определены следующие операции:

\begin{enumerate}
    \item \textbf{Объединение}: Операция объединения создает новое мультимножество, содержащее максимальную кратность каждого элемента из исходных мультимножеств. Это означает, что если элемент присутствует в обоих мультимножествах, то в результате будет взята наибольшая кратность.
    $$(A \cup B)(x) = \max(A(x), B(x))$$
    
    \item \textbf{Пересечение}: Операция пересечения формирует мультимножество, содержащее минимальную кратность каждого элемента, присутствующего в обоих исходных мультимножествах. Элементы, отсутствующие хотя бы в одном из мультимножеств, не включаются в результат.
    $$(A \cap B)(x) = \min(A(x), B(x))$$
    
    \item \textbf{Разность}: Операция разности удаляет из первого мультимножества элементы, присутствующие во втором, с учетом их кратности. Если кратность элемента во втором мультимножестве больше или равна кратности в первом, элемент полностью удаляется.
    $$(A \setminus B)(x) = (A \cap \bar B)(x)$$
    
    \item \textbf{Симметрическая разность}: Эта операция объединяет элементы, которые присутствуют только в одном из мультимножеств, исключая общие элементы. Она представляет собой объединение двух разностей мультимножеств.
    $$A \triangle B = (A \setminus B) \cup (B \setminus A)$$
    
    \item \textbf{Дополнение}: Операция дополнения создает мультимножество, содержащее все элементы универсума, которые отсутствуют в исходном мультимножестве, с их максимально возможной кратностью.
    $$\overline{A}(x) = \begin{cases} 
        \text{max\_cardinality}(x), & \text{если } A(x) = 0 \\
        0, & \text{если } A(x) > 0
    \end{cases}$$
\end{enumerate}

\subsection{Арифметические операции}

\begin{enumerate}
    \item \textbf{Сумма} (агрегатная функция над мультимножеством):
    $$\operatorname{Sum}(A) = \sum_{x \in U} A(x).$$
    
    \item \textbf{Разность} (неотрицательная разность агрегатов):
    $$\operatorname{Diff}(A,B) = \max\!\Bigl(0,\; \sum_{x \in U} A(x) \, - \, \sum_{x \in U} B(x)\Bigr).$$
    
    \item \textbf{Произведение} (агрегат по кратностям):
    $$\operatorname{Prod}(A) = \prod_{x \in U} A(x).$$
    
    \item \textbf{Деление} (целочисленное деление агрегатов):
    $$\operatorname{Div}(A,B) =
    \begin{cases}
        \left\lfloor \dfrac{\sum_{x \in U} A(x)}{\sum_{x \in U} B(x)} \right\rfloor, & \text{если } \sum_{x \in U} B(x) > 0, \\
        0, & \text{иначе.}
    \end{cases}$$
\end{enumerate}

\subsection{Взвешенная арифметика в коде Грея}

В дополнение к стандартным операциям над мультимножествами рассматривается \textit{взвешенная арифметика} на основе бинарного кода Грея. Идея состоит в том, чтобы каждому элементу универсума, представленному кодом Грея $g \in G_n$, сопоставить целое число через обратное преобразование Грея и использовать кратности элементов как веса.

\textbf{Преобразование:} Пусть $\text{grayToInt}(g)$ — функция преобразования кода Грея в неотрицательное целое число. Тогда \textit{взвешенная сумма} мультимножества $A$ определяется как
$$\text{WSum}(A) = \sum_{g \in U} A(g) \cdot \text{grayToInt}(g).$$

Аналогично определяются взвешенные разность, произведение и целочисленное деление на уровне агрегированных значений:
\begin{align*}
\text{WDiff}(A,B) &= \max\bigl(0,\, \text{WSum}(A) - \text{WSum}(B)\bigr),\\
\text{WProd}(A) &= \prod_{g \in U} \bigl(\text{grayToInt}(g)\bigr)^{A(g)},\\
\text{WDiv}(A,B) &= \begin{cases}
\left\lfloor \dfrac{\text{WSum}(A)}{\text{WSum}(B)} \right\rfloor, & \text{если } \text{WSum}(B) > 0,\\
0, & \text{иначе.}
\end{cases}
\end{align*}

\textbf{Пример.} Для $n=3$ коды Грея $\{000,001,011,010,110,111,101,100\}$ соответствуют значениям $\{0,1,2,3,4,5,6,7\}$. Если $A(001)=2$ и $A(110)=1$, то
$$\text{WSum}(A)=2\cdot 1 + 1\cdot 4 = 6.$$

\subsection{Алгоритм генерации бинарного кода Грея}

Бинарный код Грея — это система счисления, в которой два соседних значения различаются только в одном разряде.

\textbf{Рекурсивный алгоритм генерации:}
\begin{enumerate}
    \item Для $n = 1$: $G_1 = \{0, 1\}$
    \item Для $n > 1$: 
    \begin{itemize}
        \item Создать $G_{n-1}$ рекурсивно
        \item Добавить префикс '0' к каждому элементу $G_{n-1}$
        \item Добавить префикс '1' к каждому элементу $G_{n-1}$ в обратном порядке
    \end{itemize}
\end{enumerate}

\textbf{Формула:} $G_n = \{0 + g : g \in G_{n-1}\} \cup \{1 + g : g \in \text{reverse}(G_{n-1})\}$

\textbf{Пример генерации для $n = 3$:}
\begin{enumerate}
    \item $G_1 = \{0, 1\}$
    \item $G_2 = \{00, 01\} \cup \{11, 10\} = \{00, 01, 11, 10\}$
    \item $G_3 = \{000, 001, 011, 010\} \cup \{110, 111, 101, 100\} = \{000, 001, 011, 010, 110, 111, 101, 100\}$
\end{enumerate}

Как видно из примера, каждый переход между соседними кодами изменяет только один бит, что является ключевым свойством кода Грея.

\newpage

\section{Особенности реализации}

\subsection{Структуры данных}

Программа использует следующие основные структуры данных:

\begin{itemize}
    \item \texttt{vector<string> universe} — хранит элементы универсума (коды Грея)
    \item \texttt{map<string, int> universeCardinality} — хранит максимальную кратность для каждого элемента универсума
    \item \texttt{map<string, int> multiset1, multiset2} — хранят мультимножества в виде пар (элемент, кратность)
\end{itemize}

\subsection{Основные функции и методы}

\subsubsection{Генерация кода Грея}

\textbf{Функция:} \texttt{vector<string> generateGrayCode(int n)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{n} — разрядность кода Грея
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{vector<string>} — вектор строк, содержащий все коды Грея заданной разрядности
\end{itemize}

\textbf{Описание:} Рекурсивно генерирует все коды Грея для заданной разрядности, используя алгоритм построения по предыдущему коду.

\textbf{Обоснование выбора структуры данных:} Использование \texttt{vector<string>} для хранения кодов Грея является оптимальным решением по следующим причинам:
\begin{itemize}
    \item \textbf{Эффективность доступа:} Вектор обеспечивает константное время доступа к элементам по индексу O(1)
    \item \textbf{Удобство итерации:} Поддержка range-based for loops и итераторов для удобного обхода всех элементов
    \item \textbf{Динамическое управление памятью:} Автоматическое управление памятью без необходимости ручного выделения/освобождения
    \item \textbf{Совместимость с STL:} Легкая интеграция с алгоритмами стандартной библиотеки C++
    \item \textbf{Строковое представление:} Использование \texttt{string} для хранения бинарных кодов позволяет легко манипулировать отдельными битами, добавлять префиксы и выполнять конкатенацию
    \item \textbf{Читаемость:} Строковое представление делает код более понятным и удобным для отладки
\end{itemize}

\subsubsection{Инициализация универсума}

\textbf{Функция:} \texttt{void initializeUniverse()}

\textbf{Входные параметры:} Нет

\textbf{Выходные данные:} Нет (изменяет состояние объекта)

\textbf{Описание:} Генерирует универсум на основе кода Грея и случайным образом назначает максимальную кратность каждому элементу (от 1 до 10).

\subsubsection{Операции над мультимножествами}

\textbf{Функция:} \texttt{map<string,int> unionMultisets(const map<string,int>\& m1, const map<string,int>\& m2)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{m1} — первое мультимножество
    \item \texttt{m2} — второе мультимножество
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{map<string,int>} — объединение, где кратности равны $\max(m1(x),\,m2(x))$
\end{itemize}

\textbf{Описание:} Формирует объединение мультимножеств с учетом ограничений максимальной кратности элементов универсума.

\vspace{6pt}

\textbf{Функция:} \texttt{map<string,int> intersectionMultisets(const map<string,int>\& m1, const map<string,int>\& m2)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{m1} — первое мультимножество
    \item \texttt{m2} — второе мультимножество
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{map<string,int>} — пересечение, где кратности равны $\min(m1(x),\,m2(x))$
\end{itemize}

\textbf{Описание:} Строит пересечение мультимножеств, ограничивая кратности не выше заданного максимума для элементов универсума.

\vspace{6pt}

\textbf{Функция:} \texttt{map<string,int> differenceMultisets(const map<string,int>\& m1, const map<string,int>\& m2)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{m1} — уменьшаемое мультимножество
    \item \texttt{m2} — вычитаемое мультимножество
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{map<string,int>} — разность, где кратности равны $\max(0,\,m1(x)-m2(x))$
\end{itemize}

\textbf{Описание:} Удаляет из \texttt{m1} кратности элементов \texttt{m2} (не допуская отрицательных значений), соблюдая ограничения максимальной кратности универсума.

\vspace{6pt}

\textbf{Функция:} \texttt{map<string,int> symmetricDifferenceMultisets(const map<string,int>\& m1, const map<string,int>\& m2)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{m1} — первое мультимножество
    \item \texttt{m2} — второе мультимножество
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{map<string,int>} — симметрическая разность, кратности как $|m1(x)-m2(x)|$
\end{itemize}

\textbf{Описание:} Возвращает элементы, присутствующие только в одном из мультимножеств; кратности равны абсолютной разности с учетом глобальных ограничений.

\vspace{6pt}

\textbf{Функция:} \texttt{map<string,int> complementMultiset(const map<string,int>\& multiset)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{multiset} — мультимножество для дополнения
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{map<string,int>} — дополнение относительно универсума: $\maxCardinality(x)-multiset(x)$ (неотрицательно)
\end{itemize}

\textbf{Описание:} Строит дополнение мультимножества относительно сгенерированного универсума, используя заранее заданные максимальные кратности элементов.

\subsubsection{Арифметические операции}

\textbf{Функция:} \texttt{int sumMultisets(const map<string,int>\& multiset)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{multiset} — мультимножество для вычисления суммы кратностей
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{int} — сумма кратностей всех элементов
\end{itemize}

\textbf{Описание:} Вычисляет суммарную мощность мультимножества как сумму всех кратностей.

\vspace{6pt}

\textbf{Функция:} \texttt{int arithmeticDifferenceMultisets(const map<string,int>\& m1, const map<string,int>\& m2)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{m1} — первое мультимножество
    \item \texttt{m2} — второе мультимножество
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{int} — неотрицательная разность сумм кратностей: $\max(0,\,\sum m1 - \sum m2)$
\end{itemize}

\textbf{Описание:} Сравнивает агрегированные суммы кратностей и возвращает неотрицательный результат.

\vspace{6pt}

\textbf{Функция:} \texttt{int productMultisets(const map<string,int>\& multiset)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{multiset} — мультимножество для вычисления произведения кратностей
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{int} — произведение кратностей всех элементов
\end{itemize}

\textbf{Описание:} Перемножает кратности элементов мультимножества, при пустом мультимножестве возвращает 1.

\vspace{6pt}

\textbf{Функция:} \texttt{int divisionMultisets(const map<string,int>\& m1, const map<string,int>\& m2)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{m1} — делимое мультимножество
    \item \texttt{m2} — делящее мультимножество
\end{itemize}

\textbf{Выходные данные:}
\begin{itemize}
    \item \texttt{int} — целочисленное деление суммы кратностей \texttt{m1} на сумму кратностей \texttt{m2}
\end{itemize}

\textbf{Описание:} Выполняет целочисленное деление агрегированных сумм; при делении на ноль возвращает 0 и выводит сообщение об ошибке.

\subsubsection{Создание мультимножеств}

\textbf{Функция:} \texttt{void createMultisetManually(map<string,int>\& multiset, const string\& name)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{multiset} — ссылка на редактируемое мультимножество
    \item \texttt{name} — имя мультимножества для отображения в интерфейсе
\end{itemize}

\textbf{Выходные данные:} Нет (изменяет переданное мультимножество)

\textbf{Описание:} Позволяет пользователю вручную задать кратности элементов в пределах максимальных значений универсума с валидацией ввода.

\vspace{6pt}

\textbf{Функция:} \texttt{void createMultisetAutomatically(map<string,int>\& multiset, const string\& name, int cardinality)}

\textbf{Входные параметры:}
\begin{itemize}
    \item \texttt{multiset} — ссылка на редактируемое мультимножество
    \item \texttt{name} — имя мультимножества для отображения
    \item \texttt{cardinality} — требуемая суммарная мощность мультимножества
\end{itemize}

\textbf{Выходные данные:} Нет (изменяет переданное мультимножество)

\textbf{Описание:} Автоматически распределяет заданную мощность по элементам универсума случайным образом, соблюдая максимальные кратности и инварианты данных.

\subsection{Функции для взвешенной арифметики кода Грея}

В реализации используются вспомогательные функции для преобразования между кодом Грея и целыми числами, а также для выполнения взвешенных арифметических операций:
\begin{itemize}
    \item \texttt{int grayToInt(const string\& g)} — преобразует строковый код Грея в целое число с использованием поразрядного вычисления префиксной XOR-суммы.
    \item \texttt{string intToGray(int x, int n)} — преобразует целое число в код Грея длины $n$ через формулу $g = x \oplus (x \gg 1)$ с последующим форматированием до $n$ бит.
    \item \texttt{long long weightedSum(const map<string,int>\& A)} — вычисляет $\text{WSum}(A)$ как сумму весов \texttt{grayToInt(g)} с кратностями элементов.
    \item \texttt{long long weightedDiff(const map<string,int>\& A, const map<string,int>\& B)} — возвращает $\max(0,\,\text{WSum}(A)-\text{WSum}(B))$.
    \item \texttt{long long weightedProd(const map<string,int>\& A)} — считает произведение $\prod (\text{grayToInt}(g))^{A(g)}$ с проверкой переполнения при необходимости.
    \item \texttt{long long weightedDiv(const map<string,int>\& A, const map<string,int>\& B)} — выполняет целочисленное деление $\left\lfloor\dfrac{\text{WSum}(A)}{\text{WSum}(B)}\right\rfloor$ c защитой от деления на ноль.
\end{itemize}

Данные функции используются исключительно для иллюстрации расширенного подхода и не подменяют стандартные операции над мультимножествами; они работают на уровне агрегированных величин, где вес определяется положением элемента в последовательности Грея.

\newpage

\section{Результаты работы}

\subsection{Сценарий 1: Корректный ввод}

\textbf{Параметры результатов:}
\begin{itemize}
    \item Разрядность кода Грея: 3
    \item Максимальная кратность универсума: 5
    \item Способ создания: Автоматический
    \item Мощность мультимножеств: 8 и 6
\end{itemize}

\textbf{Ожидаемый результат:} Программа должна успешно сгенерировать универсум из 8 элементов (коды Грея для 3 разрядов), создать два мультимножества и выполнить все операции.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{1correct.png}
    \caption{Демонстрация работы программы с корректным вводом}
    \label{fig:correct_input}
    % [Здесь будет размещен скриншот работы программы с корректным вводом]
\end{figure}

\subsection{Сценарий 2: Некорректный ввод разрядности}

\textbf{Параметры тестирования:}
\begin{itemize}
    \item Ввод разрядности: 15 (превышает максимально допустимое значение 10)
    \item Ожидаемое поведение: Запрос повторного ввода
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{2.png}
    \caption{Обработка некорректного ввода разрядности}
    \label{fig:invalid_bitwidth}
    % [Здесь будет размещен скриншот обработки некорректного ввода разрядности]
\end{figure}

\subsection{Сценарий 3: Некорректный ввод кратности}

\textbf{Параметры тестирования:}
\begin{itemize}
    \item Ввод кратности элемента: 12 (превышает максимальную кратность элемента)
    \item Ожидаемое поведение: Запрос повторного ввода
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{3.png}
    \caption{Обработка некорректного ввода кратности}
    \label{fig:invalid_multiplicity}
    % [Здесь будет размещен скриншот обработки некорректного ввода кратности]
\end{figure}

\subsection{Сценарий 4: Деление на ноль}

\textbf{Параметры тестирования:}
\begin{itemize}
    \item Мультимножество 1: содержит элементы
    \item Мультимножество 2: пустое (сумма кратностей = 0)
    \item Ожидаемое поведение: Вывод сообщения об ошибке и возврат 0
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{4.png}
    \caption{Обработка деления на ноль}
    \label{fig:division_by_zero}
    % [Здесь будет размещен скриншот обработки деления на ноль]
\end{figure}

\subsection{Сценарий 5: Демонстрация всех операций}

\textbf{Параметры тестирования:}
\begin{itemize}
    \item Разрядность: 2
    \item Ручное создание мультимножеств
    \item Демонстрация всех операций над множествами и арифметических операций
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{5together.1.jpeg}
    \caption{Результаты выполнения всех операций над мультимножествами}
    \label{fig:all_operations}
    % [Здесь будет размещен скриншот с результатами всех операций]
\end{figure}

\subsection{Сценарий 6: Взвешенная арифметика кода Грея}

\textbf{Параметры тестирования:}
\begin{itemize}
    \item Разрядность кода Грея: 3
    \item Мультимножество $A$: несколько элементов с различными кратностями
    \item Мультимножество $B$: другой набор элементов
\end{itemize}

\textbf{Ожидаемый результат:} Корректный расчет $\text{WSum}(A)$, $\text{WSum}(B)$, а также $\text{WDiff}(A,B)$ и $\text{WDiv}(A,B)$ (целочисленно).

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{6.png}
    \caption{Демонстрация взвешенной арифметики на кодах Грея}
    \label{fig:weighted_gray}
    % [Здесь будет размещен скриншот демонстрации взвешенной арифметики]
\end{figure}

\newpage

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
\refstepcounter{section}
\setcounter{subsection}{0}
\subsection{Реализованные возможности}

В ходе выполнения лабораторной работы была успешно реализована программа, включающая в себя:

\begin{itemize}
    \item Алгоритм генерации бинарного кода Грея рекурсивным методом
    \item Систему создания мультимножеств с ограничениями по максимальной кратности элементов
    \item Полный набор операций над мультимножествами (объединение, пересечение, разность, симметрическая разность, дополнение)
    \item Арифметические операции с защитой от некорректных вычислений
    \item Два способа создания мультимножеств (ручной и автоматический)
    \item Систему валидации пользовательского ввода
    %\item Удобный пользовательский интерфейс с меню
\end{itemize}

\subsection{Достоинства реализованного алгоритма}

\begin{itemize}
    \item \textbf{Гибкость:} Поддержка различных разрядностей кода Грея (1-10)
    \item \textbf{Производительность:} Эффективные алгоритмы с временной сложностью O(n) для большинства операций
    \item \textbf{Интерфейс, основанный на ООП:} Четкое разделение ответственности (генерация универсума, операции над мультимножествами, ввод/вывод) упрощает сопровождение и расширение кода; инкапсуляция инвариантов (максимальные кратности) повышает надежность.
    \item \textbf{Переиспользование базовых операций:} Функции над мультимножествами (например, \texttt{unionMultisets}, \texttt{intersectionMultisets}) используются для построения и валидации более высокоуровневых вычислений (например, арифметической разности), что уменьшает дублирование логики.
\end{itemize}

\subsection{Недостатки и ограничения}

\begin{itemize}
    \item \textbf{Ограниченная разрядность:} Максимальная разрядность кода Грея ограничена 10 битами
    \item \textbf{Память:} Используемые структуры данных (например, \texttt{vector<string>} для универсума и \texttt{map<string,int>} для мультимножеств) становятся неэффективными при больших $n$: строки занимают много памяти, ассоциативные контейнеры имеют высокий накладной расход на узлы и аллокаторы. Для больших размеров кода Грея требуется оптимизация представления и хранения данных.
    \item \textbf{Валидация:} Некоторые типы некорректного ввода могут требовать дополнительной обработки
\end{itemize}

\subsection{Масштабирование}

Алгоритм может быть масштабирован для работы с большими разрядностями путем:
\begin{itemize}
    \item Использования более эффективных структур данных
    \begin{itemize}
        \item Представление кодов Грея не как \texttt{string}, а как битовые маски: \texttt{std::vector<uint64\_t>} или \texttt{std::bitset<n>} (или динамические битовые вектора) с плотной упаковкой битов
        \item Замена \texttt{map<string,int>} на плотные структуры: \texttt{unordered\_map} с пользовательским хэшем по битовому представлению или плоские хэш-таблицы (напр. robin-hood/\texttt{flat\_hash\_map})
        \item Индексация элементов универсума целыми индексами и хранение кратностей в \texttt{std::vector<uint8\_t>/uint16\_t}, чтобы исключить дублирование ключей-строк
    \end{itemize}
    \item Реализации итеративного алгоритма генерации кода Грея
    \item Добавления поддержки параллельных вычислений
    \item Оптимизации памяти для хранения больших универсумов
    \begin{itemize}
        \item Бит-пэкинг: хранить коды Грея в виде компактных битовых контейнеров; один код из $n$ бит занимает $\lceil n/64 \rceil$ 64-битных слов вместо $n$ символов
        \item Интернирование/индексация: хранить единственный массив универсума и ссылаться на элементы по индексу; мультимножества хранить как массив кратностей по индексу без повторения строковых ключей
        \item Сжатие кратностей: выбирать минимально достаточный тип (\texttt{uint8\_t} или \texttt{uint16\_t}) исходя из максимальной кратности; это уменьшает объем памяти в 4–8 раз по сравнению с \texttt{int}
        \item Разреженное хранение: для мультимножеств малой плотности хранить только пары \texttt{<index, count>} в компактных векторах, отсортированных по индексу, с бинарным поиском
        \item Ленивое построение: не материализовывать весь универсум сразу; генерировать элементы на лету итераторами там, где это возможно (стриминг)
    \end{itemize}
\end{itemize}

\subsection{Дополнительная работа: взвешенная арифметика}

В ходе выполнения работы была реализована дополнительная функциональность — взвешенная арифметика на кодах Грея. Данный подход позволяет оценивать мультимножества не только по кратностям, но и с учетом позиции элементов в последовательности Грея (через преобразование \texttt{grayToInt}). Это расширяет аналитические возможности программы, позволяя применять агрегированные метрики и сравнения мультимножеств на уровне числовых весов.

Преимущества: естественная интерпретация веса элемента, целочисленные операции, совместимость с существующими структурами данных. Ограничения: возможный рост значений (произведение), чувствительность к выбранному способу взвешивания.

\newpage

\begin{thebibliography}{9}

%\bibitem{gray_code}
%Gray, Frank. "Pulse code communication." U.S. Patent 2,632,058. 1953.

%\bibitem{multiset_theory}
%Blizard, Wayne D. "Multiset theory." Notre Dame Journal of Formal Logic 30.1 (1989): 36-66.

%\bibitem{discrete_math}
%Rosen, Kenneth H. Discrete mathematics and its applications. McGraw-Hill, 2018.

%\bibitem{algorithms}
%Cormen, Thomas H., et al. Introduction to algorithms. MIT press, 2009.

%\bibitem{cpp_reference}
%Stroustrup, Bjarne. The C++ programming language. Addison-Wesley Professional, 2013.

% Русская версия списка литературы:
\bibitem{novikov_2009}
 Новиков Ф.А. Дискретная математика для программистов. 3-е изд. Санкт-Петербург : Питер Пресс, 2009. - 384 с. (Дата обращения 20.09.2025)

 \bibitem{telematics_spbstu}
 Секция "Телематика"/ текст : электронный / URL: https://tema.spbstu.ru/dismath/ (Дата обращения 20.09.2025)

 \bibitem{gray_code_ru}
 Грей, Фрэнк. "Импульсно-кодовая связь." Патент США 2,632,058. 1953. URL: https://patents.google.com/patent/US2632058 (Дата обращения 20.09.2025)

 \bibitem{multiset_theory_ru}
 Близзард, Уэйн Д. "Теория мультимножеств." Журнал формальной логики Нотр-Дама 30.1 (1989): 36-66. URL: https://projecteuclid.org/journals/notre-dame-journal-of-formal-logic/volume-30/issue-1/Multiset-Theory/10.1305/ndjfl/1093634995.full (Дата обращения 20.09.2025)

% \bibitem{discrete_math_ru}
% Розен, Кеннет Х. Дискретная математика и её приложения. McGraw-Hill, 2018.

% \bibitem{algorithms_ru}
% Кормен, Томас Х. и др. Алгоритмы: построение и анализ. MIT press, 2009.

% \bibitem{cpp_reference_ru}
% Страуструп, Бьярне. Язык программирования C++. Addison-Wesley Professional, 2013.

\end{thebibliography}

\newpage
\appendix
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение A : исходный код}

В данном приложении приведены исходные коды модулей программы.

\subsection{Заголовочный файл \texttt{funcs.h}}
\lstinputlisting[language=C++,caption={Содержимое файла funcs.h}]{funcs.h}

\subsection{Реализация функций \texttt{funcs.cpp}}
\lstinputlisting[language=C++,caption={Содержимое файла funcs.cpp}]{funcs.cpp}

\subsection{Точка входа \texttt{main.cpp}}
\lstinputlisting[language=C++,caption={Содержимое файла main.cpp}]{main.cpp}


\end{document}